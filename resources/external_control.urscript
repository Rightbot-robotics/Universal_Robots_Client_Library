# HEADER_BEGIN

{{BEGIN_REPLACE}}

steptime = get_steptime()

textmsg("ExternalControl: steptime=", steptime)
MULT_jointstate = {{JOINT_STATE_REPLACE}}
MULT_time = {{TIME_REPLACE}}

STOPJ_ACCELERATION = 4.0

#Constants
SERVO_UNINITIALIZED = -1
SERVO_IDLE = 0
SERVO_RUNNING = 1

MODE_STOPPED = -2
MODE_UNINITIALIZED = -1
MODE_IDLE = 0
MODE_SERVOJ = 1
MODE_SPEEDJ = 2
MODE_FORWARD = 3
MODE_SPEEDL = 4
MODE_POSE = 5
MODE_FREEDRIVE = 6
MODE_TOOL_IN_CONTACT = 7
PAYLOAD_ESTIMATION = 8
# Data dimensions of the message received on the reverse interface
REVERSE_INTERFACE_DATA_DIMENSION = 8

TRAJECTORY_MODE_RECEIVE = 1
TRAJECTORY_MODE_CANCEL = -1

TRAJECTORY_POINT_JOINT = 0
TRAJECTORY_POINT_CARTESIAN = 1
TRAJECTORY_POINT_JOINT_SPLINE = 2
TRAJECTORY_DATA_DIMENSION = 3*6 + 1

TRAJECTORY_RESULT_SUCCESS = 0
TRAJECTORY_RESULT_CANCELED = 1
TRAJECTORY_RESULT_FAILURE = 2

ZERO_FTSENSOR = 0
SET_PAYLOAD = 1
SET_TOOL_VOLTAGE = 2
START_FORCE_MODE = 3
END_FORCE_MODE = 4
START_TOOL_CONTACT = 5
END_TOOL_CONTACT = 6
SET_GRAVITY = 7
SET_DYNAMIC_PAYLOAD = 8
SET_BOX_SLIP_DETECTION = 9
SCRIPT_COMMAND_DATA_DIMENSION = 26

DP_TOP_LIFT = 0
DP_FRONT_LIFT = 1
DP_FRONT_DRAG = 2
DP_TOP_DRAG = 3
DP_STATE_INACTIVE = 0
DP_STATE_ESTIMATING = 1
DP_STATE_ESTIMATION_COMPLETE = 2
DP_STATE_TCP_ZERO_VEL = 3


DETECT_BOX_SLIP_ACTIVATE = 0
DETECT_BOX_SLIP_DEACTIVATE = 1

FREEDRIVE_MODE_START = 1
FREEDRIVE_MODE_STOP = -1

UNTIL_TOOL_CONTACT_RESULT_SUCCESS = 0
UNTIL_TOOL_CONTACT_RESULT_CANCELED = 1

PAYLOAD_SET_EXECUTION_COMPLETE = 2

SPLINE_CUBIC = 1
SPLINE_QUINTIC = 2

#Global variables are also showed in the Teach pendants variable list
global cmd_servo_state = SERVO_UNINITIALIZED
global cmd_servo_qd = [0.0, 0.0, 0.0, 0.0, 0.0, 0.0]
global cmd_servo_q = get_actual_joint_positions()
global cmd_servo_q_last = get_actual_joint_positions()
global cmd_twist = [0.0, 0.0, 0.0, 0.0, 0.0, 0.0]
global extrapolate_count = 0
global extrapolate_max_count = 0
global control_mode = MODE_UNINITIALIZED
global trajectory_points_left = 0
global last_spline_qdd = [0, 0, 0, 0, 0, 0]
global tool_contact_running = False
global target_payload_mass = 0
global target_payload_cog = [0.0, 0.0, 0.0]
global run_set_payload_loop = False
global payload_loop_first_pass = True
global payload_value_step = 0.0
global is_initial_script = {{IS_INITIAL_SCRIPT_REPLACE}}
global consider_register_payload_values = False
global default_payload_set = False
global deafult_payload_mass = {{DEFAULT_PAYLOAD_MASS_REPLACE}}
global deafult_payload_cog = [{{DEFAULT_PAYLOAD_COG_X_REPLACE}}, {{DEFAULT_PAYLOAD_COG_Y_REPLACE}}, {{DEFAULT_PAYLOAD_COG_Z_REPLACE}}]
global register_payload_mass = 0.0
global register_payload_cog = [0.0, 0.0, 0.0]
global force_mode_payload_set_active = False
global payload_estimation_thread_started = False
global force_mode_payload_set_max_force = 400.0
global ft_raw_wrench = [0.0, 0.0, 0.0, 0.0, 0.0, 0.0]
global ft_raw_wrench_offset = [0.0, 0.0, 0.0, 0.0, 0.0, 0.0]
global ft_compensated = [0.0, 0.0, 0.0, 0.0, 0.0, 0.0]
global curr_gripper_ft = [0.0, 0.0, 0.0, 0.0, 0.0, 0.0]
global gripper_ft_offset = [0.0, 0.0, 0.0, 0.0, 0.0, 0.0]
global current_raw_force = 0.0
global current_raw_torque = 0.0
global force_to_apply = 0.0
global payload_estim_start_pos = p[0.0, 0.0, 0.0, 0.0, 0.0, 0.0]
global payload_estim_start_pos_inv = p[0.0, 0.0, 0.0, 0.0, 0.0, 0.0]
global payload_estim_curr_pos = p[0.0, 0.0, 0.0, 0.0, 0.0, 0.0]
global payload_estim_pos_diff = [0.0, 0.0, 0.0]
global eff_pose_diff = p[0.0, 0.0, 0.0, 0.0, 0.0, 0.0]
global payload_estim_speed_check_counter = 0.0
global curr_tcp_speed = p[0.0, 0.0, 0.0, 0.0, 0.0, 0.0]
global payload_estim_command_type = -1
global payload_estim_move_distance = 0.0
global payload_estim_secondary_move_distance = 0.0
global payload_estim_move_speed = 0.05
global calc_cog = deafult_payload_cog
global extra_mass = 0.0
global mass_additional = 4.0
global p_base_wrt_tcp = p[0.0, 0.0, 0.0, 0.0, 0.0, 0.0]
global p_gravity_wrt_tcp = p[0.0, 0.0, 0.0, 0.0, 0.0, 0.0]
global gravity_at_tcp = p[0.0, 0.0, 0.0, 0.0, 0.0, 0.0]
global gravity_at_base = p[0.0, 0.0, -9.81, 0.0, 0.0, 0.0]
global lift_in_progress = False
global complaint_axes = [0, 0, 0, 0, 0, 0]
global force_vector = [0.0, 0.0, 0.0, 0.0, 0.0, 0.0]
global force_mode_limits = [0.0, 0.0, 0.0, 0.0, 0.0, 0.0]
global min_estim_distance_front_lifting = 0.01
global min_estim_distance_default = 0.0
global min_estim_distance = 0.0
global started_setting_payload = False
global tool_contact_first_pass = False
global new_step_back = 0
global tool_contact_force_threshold = 120.0
global tool_contact_deviation_threshold = 0.002
global payload_estim_result = DP_STATE_INACTIVE
global payload_estim_result_state_active_time = 1.0
global payload_estim_result_state_active_count = 0
global detect_box_slip = False
global joints_position_deviation = [0.0, 0.0, 0.0, 0.0, 0.0, 0.0]
global max_position_deviation =  0.0
global idx = 0
global trigger_position_deviation = 0.0028
global force_mode_payload_loop_first_pass = False
global payload_setting_window = 50
global mass_calc_history = make_list(0, struct(mass=0.0, cog=0.0), payload_setting_window)

# Global thread variables
thread_move = 0
thread_trajectory = 0
thread_script_commands = 0
thread_services_execution = 0

def set_servo_setpoint(q):
  cmd_servo_state = SERVO_RUNNING
  cmd_servo_q_last = cmd_servo_q
  cmd_servo_q = q
end

def extrapolate():
  diff = [cmd_servo_q[0] - cmd_servo_q_last[0], cmd_servo_q[1] - cmd_servo_q_last[1], cmd_servo_q[2] - cmd_servo_q_last[2], cmd_servo_q[3] - cmd_servo_q_last[3], cmd_servo_q[4] - cmd_servo_q_last[4], cmd_servo_q[5] - cmd_servo_q_last[5]]
  cmd_servo_q_last = cmd_servo_q
  cmd_servo_q = [cmd_servo_q[0] + diff[0], cmd_servo_q[1] + diff[1], cmd_servo_q[2] + diff[2], cmd_servo_q[3] + diff[3], cmd_servo_q[4] + diff[4], cmd_servo_q[5] + diff[5]]

  return cmd_servo_q
end

thread servoThread():
  textmsg("ExternalControl: Starting servo thread")
  state = SERVO_IDLE
  while control_mode == MODE_SERVOJ:
    enter_critical
    q = cmd_servo_q
    do_extrapolate = False
    if (cmd_servo_state == SERVO_IDLE):
      do_extrapolate = True
    end
    state = cmd_servo_state
    if cmd_servo_state > SERVO_UNINITIALIZED:
      cmd_servo_state = SERVO_IDLE
    end

    if do_extrapolate:
      extrapolate_count = extrapolate_count + 1
      if extrapolate_count > extrapolate_max_count:
        extrapolate_max_count = extrapolate_count
      end

      q = extrapolate()
      servoj(q, t=steptime, {{SERVO_J_REPLACE}})

    elif state == SERVO_RUNNING:
      extrapolate_count = 0
      servoj(q, t=steptime, {{SERVO_J_REPLACE}})
    else:
      extrapolate_count = 0
      sync()
    end
    exit_critical
  end
  textmsg("ExternalControl: servo thread ended")
  stopj(STOPJ_ACCELERATION)
end

# Helpers for speed control
def set_speed(qd):
  cmd_servo_qd = qd
  control_mode = MODE_SPEEDJ
end

thread speedThread():
  textmsg("ExternalControl: Starting speed thread")
  while control_mode == MODE_SPEEDJ:
    qd = cmd_servo_qd
    speedj(qd, 40.0, steptime)
  end
  textmsg("ExternalControl: speedj thread ended")
  stopj(STOPJ_ACCELERATION)
end

def cubicSplineRun(end_q, end_qd, time, last_point=False):
  local str = str_cat(end_q, str_cat(end_qd, time))
  textmsg("Cubic spline arg: ", str)

  # Zero time means zero length and therefore no motion to execute
  if time > 0.0:
    local start_q = get_target_joint_positions()
    local start_qd = get_target_joint_speeds()

    # Coefficients0 is not included, since we do not need to calculate the position
    local coefficients1 = start_qd
    local coefficients2 = (-3 * start_q + end_q * 3 - start_qd * 2 * time - end_qd * time) / pow(time, 2)
    local coefficients3 = (2 * start_q - 2 * end_q + start_qd * time + end_qd * time) / pow(time, 3)
    local coefficients4 = [0.0, 0.0, 0.0, 0.0, 0.0, 0.0]
    local coefficients5 = [0.0, 0.0, 0.0, 0.0, 0.0, 0.0]
    jointSplineRun(coefficients1, coefficients2, coefficients3, coefficients4, coefficients5, time, last_point)
  end
end

def quinticSplineRun(end_q, end_qd, end_qdd, time, last_point=False):
  local str = str_cat(end_q, str_cat(end_qd, str_cat(end_qdd, time)))
  textmsg("Quintic spline arg: ", str)

  # Zero time means zero length and therefore no motion to execute
  if time > 0.0:
    local start_q = get_target_joint_positions()
    local start_qd = get_target_joint_speeds()
    local start_qdd = last_spline_qdd

    # Pre-calculate coefficients
    local TIME2 = pow(time, 2)
    # Coefficients0 is not included, since we do not need to calculate the position
    local coefficients1 = start_qd
    local coefficients2 = 0.5 * start_qdd
    local coefficients3 = (-20.0 * start_q + 20.0 * end_q - 3.0 * start_qdd * TIME2 + end_qdd * TIME2 - 12.0 * start_qd * time - 8.0 * end_qd * time) / (2.0 * pow(time, 3))
    local coefficients4 = (30.0 * start_q - 30.0 * end_q + 3.0 * start_qdd * TIME2 - 2.0 * end_qdd * TIME2 + 16.0 * start_qd * time + 14.0 * end_qd * time) / (2.0 * pow(time, 4))
    local coefficients5 = (-12.0 * start_q + 12.0 * end_q - start_qdd * TIME2 + end_qdd * TIME2 - 6.0 * start_qd * time - 6.0 * end_qd * time) / (2.0 * pow(time, 5))
    jointSplineRun(coefficients1, coefficients2, coefficients3, coefficients4, coefficients5, time, last_point)
  end
end

def jointSplineRun(coefficients1, coefficients2, coefficients3, coefficients4, coefficients5, splineTotalTravelTime, last_point):
  # Initialize variables
  local splineTimerTraveled = 0.0
  local scaled_step_time = get_steptime()
  local scaling_factor = 1.0
  local slowing_down = False
  local slowing_down_time = 0.0

  # Interpolate the spline in whole time steps
  while (splineTotalTravelTime - splineTimerTraveled) > get_steptime():
    local time_left = splineTotalTravelTime - splineTimerTraveled

    # Maximum deceleration in rad/s^2
    local max_deceleration = 15
    # Maximum allowable joint speed in rad/s
    local max_speed = 6.283185
    # The time needed to decelerate with 15 rad/s^2 to reach zero velocity when we move at maximum velocity.
    local deceleration_time = max_speed / max_deceleration

    # If the velocity is too large close to the end of the trajectory we scale the
    # trajectory, such that we follow the positional part of the trajectory, but end with zero velocity.
    if (time_left <= deceleration_time) and (last_point == True):
      if slowing_down == False:

        # Peek what the joint velocities will be if we take a full time step
        local qd = jointSplinePeek(coefficients1, coefficients2, coefficients3, coefficients4, coefficients5, splineTimerTraveled + get_steptime())
        # Compute the time left to decelerate if we take a full time step
        local x = deceleration_time - (time_left - get_steptime())
        slowing_down = checkSlowDownRequired(x, qd, max_speed, max_deceleration)

        if slowing_down == True:
          # This will ensure that we scale the trajectory right away
          slowing_down_time = time_left + get_steptime()
          textmsg("Velocity is too fast towards the end of the trajectory. The robot will be slowing down, while following the positional part of the trajectory.")
        end
      end

      if slowing_down == True:
        # Compute scaling factor based on time left and total slowing down time
        scaling_factor = time_left / slowing_down_time
        scaled_step_time = get_steptime() * scaling_factor
      end
    end

    splineTimerTraveled = splineTimerTraveled + scaled_step_time
    # USED_IN_TEST_SPLINE_INTERPOLATION write_output_float_register(1, splineTimerTraveled)
    jointSplineStep(coefficients1, coefficients2, coefficients3, coefficients4, coefficients5, splineTimerTraveled, get_steptime(), scaling_factor)
  end

  # Make sure that we approach zero velocity slowly, when slowing down
  if slowing_down == True:
    local qd = get_actual_joint_speeds()
    while norm(qd) > 0.00001:
      local time_left = splineTotalTravelTime - splineTimerTraveled

      # Compute scaling factor based on time left and total slowing down time
      scaling_factor = time_left / slowing_down_time
      scaled_step_time = get_steptime() * scaling_factor

      splineTimerTraveled = splineTimerTraveled + scaled_step_time
      # USED_IN_TEST_SPLINE_INTERPOLATION write_output_float_register(1, splineTimerTraveled)
      jointSplineStep(coefficients1, coefficients2, coefficients3, coefficients4, coefficients5, splineTimerTraveled, get_steptime(), scaling_factor)

      qd = get_actual_joint_speeds()
    end
    scaling_factor = 0.0
  end

  # Last part of the spline which uses less than one time step
  local timeLeftToTravel = splineTotalTravelTime - splineTimerTraveled

  # To round off the float to the steptime step when it is very close to that number (1e-15)
  if timeLeftToTravel == get_steptime():
    timeLeftToTravel = get_steptime()
  end

  jointSplineStep(coefficients1, coefficients2, coefficients3, coefficients4, coefficients5, splineTotalTravelTime, timeLeftToTravel, scaling_factor)
end

def jointSplineStep(coefficients1, coefficients2, coefficients3, coefficients4, coefficients5, splineTimerTraveled, timestep, scaling_factor):
  local qd = coefficients1 + 2.0 * splineTimerTraveled * coefficients2 + 3.0 * pow(splineTimerTraveled, 2) * coefficients3 + 4.0 * pow(splineTimerTraveled, 3) * coefficients4 + 5.0 * pow(splineTimerTraveled, 4) * coefficients5
  last_spline_qdd = 2.0 * coefficients2 + 6.0 * splineTimerTraveled * coefficients3 + 12.0 * pow(splineTimerTraveled, 2) * coefficients4 + 20.0 * pow(splineTimerTraveled, 3) * coefficients5
  qd = qd * scaling_factor
  speedj(qd, 1000, timestep)
end

# Helper function to see what the velocity will be if we take a full step
def jointSplinePeek(coefficients1, coefficients2, coefficients3, coefficients4, coefficients5, splineTimerTraveled):
  local qd = coefficients1 + 2.0 * splineTimerTraveled * coefficients2 + 3.0 * pow(splineTimerTraveled, 2) * coefficients3 + 4.0 * pow(splineTimerTraveled, 3) * coefficients4 + 5.0 * pow(splineTimerTraveled, 4) * coefficients5
  return qd
end

# \brief Helper function to figure out if we need to slown down velocity at the last part of the last spline segment.
#
# The max_speed and max_deceleration is used to compute a linear velocity profile as function of the time left to decelerate,
# then we can use the time left to decelerate to find the maximum allowed speed given the time we have left. If we are above
# the maximum allowed speed, we start slowing down.
#
# \param 'x' is the time left to decelerate.
# \param 'qd' is the velocity if we take a full step ahead in the spline.
# \param 'max_speed' maximum allowed joint speed 6.283185 rad/s
# \param 'max_deceleration' is the maximum allowed deceleration 15 rad/s^2.
def checkSlowDownRequired(x, qd, max_speed, max_deceleration):
  local max_allowable_speed = max_speed - x * max_deceleration
  local idx = 0
  while idx < 6:
    if norm(qd[idx]) > max_allowable_speed:
      return True
    end
    idx = idx + 1
  end
  return False
end

thread trajectoryThread():
  textmsg("Executing trajectory. Number of points: ", trajectory_points_left)
  local INDEX_TIME = TRAJECTORY_DATA_DIMENSION
  local INDEX_BLEND = INDEX_TIME + 1
  # same index as blend parameter, depending on point type
  local INDEX_SPLINE_TYPE = INDEX_BLEND
  local INDEX_POINT_TYPE = INDEX_BLEND + 1
  last_spline_qdd = [0, 0, 0, 0, 0, 0]
  enter_critical
  while trajectory_points_left > 0:
    #reading trajectory point + blend radius + type of point (cartesian/joint based)
    local raw_point = socket_read_binary_integer(TRAJECTORY_DATA_DIMENSION+1+1, "trajectory_socket", get_steptime())
    trajectory_points_left = trajectory_points_left - 1

    if raw_point[0] > 0:
      local q = [ raw_point[1]/ MULT_jointstate, raw_point[2]/ MULT_jointstate, raw_point[3]/ MULT_jointstate, raw_point[4]/ MULT_jointstate, raw_point[5]/ MULT_jointstate, raw_point[6]/ MULT_jointstate]
      local tmptime = raw_point[INDEX_TIME] / MULT_time
      local blend_radius = raw_point[INDEX_BLEND] / MULT_time
      local last_point = False
      if trajectory_points_left == 0:
        blend_radius = 0.0
        last_point = True
      end
      # MoveJ point
      if raw_point[INDEX_POINT_TYPE] == TRAJECTORY_POINT_JOINT:
        movej(q, t=tmptime, r=blend_radius)

        # reset old acceleration
        last_spline_qdd = [0, 0, 0, 0, 0, 0]

      # Movel point
      elif raw_point[INDEX_POINT_TYPE] == TRAJECTORY_POINT_CARTESIAN:
        movel(p[q[0], q[1], q[2], q[3], q[4], q[5]], t=tmptime, r=blend_radius)

        # reset old acceleration
        last_spline_qdd = [0, 0, 0, 0, 0, 0]

      # Joint spline point
      elif raw_point[INDEX_POINT_TYPE] == TRAJECTORY_POINT_JOINT_SPLINE:

        # Cubic spline
        if raw_point[INDEX_SPLINE_TYPE] == SPLINE_CUBIC:
          qd = [ raw_point[7] / MULT_jointstate, raw_point[8] / MULT_jointstate, raw_point[9] / MULT_jointstate, raw_point[10] / MULT_jointstate, raw_point[11] / MULT_jointstate, raw_point[12] / MULT_jointstate]
          cubicSplineRun(q, qd, tmptime, last_point)
          # reset old acceleration
          last_spline_qdd = [0, 0, 0, 0, 0, 0]

        # Quintic spline
        elif raw_point[INDEX_SPLINE_TYPE] == SPLINE_QUINTIC:
          qd = [ raw_point[7] / MULT_jointstate, raw_point[8] / MULT_jointstate, raw_point[9] / MULT_jointstate, raw_point[10] / MULT_jointstate, raw_point[11] / MULT_jointstate, raw_point[12] / MULT_jointstate]
          qdd = [ raw_point[13]/ MULT_jointstate, raw_point[14]/ MULT_jointstate, raw_point[15]/ MULT_jointstate, raw_point[16]/ MULT_jointstate, raw_point[17]/ MULT_jointstate, raw_point[18]/ MULT_jointstate]
          quinticSplineRun(q, qd, qdd, tmptime, last_point)
        else:
          textmsg("Unknown spline type given:", raw_point[INDEX_POINT_TYPE])
          clear_remaining_trajectory_points()
          socket_send_int(TRAJECTORY_RESULT_FAILURE, "trajectory_socket")
        end
      end
    end
  end
  exit_critical
  socket_send_int(TRAJECTORY_RESULT_SUCCESS, "trajectory_socket")
  textmsg("Trajectory finished")
end

def clear_remaining_trajectory_points():
  while trajectory_points_left > 0:
    raw_point = socket_read_binary_integer(TRAJECTORY_DATA_DIMENSION+2, "trajectory_socket")
    trajectory_points_left = trajectory_points_left - 1
  end
end

# Helpers for speed control
def set_speedl(twist):
  cmd_twist = twist
  control_mode = MODE_SPEEDL
end

thread speedlThread():
  textmsg("Starting speedl thread")
  while control_mode == MODE_SPEEDL:
    twist = cmd_twist
    speedl(twist, 40.0, steptime)
  end
  textmsg("speedl thread ended")
  stopj(STOPJ_ACCELERATION)
end

thread servoThreadP():
  textmsg("Starting pose servo thread")
  state = SERVO_IDLE
  while control_mode == MODE_POSE:
    enter_critical
    q = cmd_servo_q
    do_extrapolate = False
    if (cmd_servo_state == SERVO_IDLE):
      do_extrapolate = True
    end
    state = cmd_servo_state
    if cmd_servo_state > SERVO_UNINITIALIZED:
      cmd_servo_state = SERVO_IDLE
    end

    if do_extrapolate:
      extrapolate_count = extrapolate_count + 1
      if extrapolate_count > extrapolate_max_count:
        extrapolate_max_count = extrapolate_count
      end

      q = extrapolate()
      servoj(q, t=steptime, {{SERVO_J_REPLACE}})

    elif state == SERVO_RUNNING:
      extrapolate_count = 0
      servoj(q, t=steptime, {{SERVO_J_REPLACE}})
    else:
      extrapolate_count = 0
      sync()
    end
    exit_critical
  end
  textmsg("pose servo thread ended")
  stopj(STOPJ_ACCELERATION)
end

def set_servo_pose(pose):
  cmd_servo_state = SERVO_RUNNING
  cmd_servo_q_last = cmd_servo_q
  cmd_servo_q = get_inverse_kin(pose, cmd_servo_q)
end

def tool_contact_detection():
  if tool_contact_first_pass == True:
    textmsg("Entered tool contact loop")
    tool_contact_first_pass = False
  end
  
  step_back = tool_contact(direction = p[0, 0, 0, 0, 0, 0])
  if step_back > 0:
    textmsg("Tool contact detected by checking contact on all direction")
  end

  new_step_back = tool_contact(direction = get_actual_tcp_speed())
  if new_step_back > 0:
    textmsg("Tool contact detected along tcp speed direction")
    step_back = new_step_back
  end

  new_step_back = tool_contact()
  if new_step_back > 0:
    textmsg("Tool contact detection in tool_contact() function with no args")
    step_back = new_step_back
  end

  ft_compensated = ft_raw_wrench - ft_raw_wrench_offset
  if force() > tool_contact_force_threshold:
    textmsg("Tool contact by force. Force exceeded the threshold ", tool_contact_force_threshold)
    textmsg("Detected force: ", force())
    step_back = 2
  end

  joints_position_deviation = get_target_joint_positions() - get_actual_joint_positions()
  max_position_deviation = 0.0
  idx = 0
  while idx < 6:
    if norm(joints_position_deviation[idx]) > max_position_deviation:
      max_position_deviation = norm(joints_position_deviation[idx])
    end
    idx = idx + 1
  end
  if max_position_deviation > tool_contact_deviation_threshold:
    textmsg("Tool contact by position deviation. Current deviation: ", max_position_deviation)
    step_back = 2
  end

  # If tool contact is detected stop movement and move back to intial contact point
  if step_back > 0:
    textmsg("tool contact detected!")
    textmsg("Detected force from custom method: ", norm([ft_compensated[0], ft_compensated[1], ft_compensated[2]]))
    textmsg("Last detected joint deviation: ", max_position_deviation)
    if control_mode == MODE_FORWARD:
      kill thread_trajectory
      clear_remaining_trajectory_points()
    elif control_mode == MODE_FREEDRIVE:
      textmsg("Leaving freedrive mode")
      end_freedrive_mode()
    else:
      kill thread_move
    end

    # Set control mode to tool in contact, should be cleared by stopping tool contact detection
    control_mode = MODE_TOOL_IN_CONTACT
    stopl(10)
    # force_mode(get_actual_tcp_pose(), [0, 0, 1, 0, 0, 0], [0, 0, 0, 0, 0, 0], 2, [0.1, 0.1, 0.05, 0.785, 0.785, 0.785])

    # Move to initial contact point
    # q = get_actual_joint_positions_history(step_back/2)
    # movel(q)
    socket_send_int(UNTIL_TOOL_CONTACT_RESULT_SUCCESS, "script_command_socket")
  end
end

def set_payload_loop():
  if payload_loop_first_pass:
    textmsg("Started payload setting loop")
    payload_value_step = (target_payload_mass - get_target_payload()) / (1.0 / get_steptime())
    payload_loop_first_pass = False
  end

  new_payload = get_target_payload() + payload_value_step
  if ((target_payload_mass - new_payload) * payload_value_step) > 0:
    set_target_payload(new_payload, target_payload_cog)
  else:
    textmsg("Setting final payload of ", target_payload_mass)
    set_target_payload(target_payload_mass, target_payload_cog)
    textmsg("Final payload set.")
    run_set_payload_loop = False
  end
end

def record_payload_value(mass, cog):
  local mid_index = 0
  local start_index = 0
  local end_index = mass_calc_history.length() - 1
  local loop_break = False

  while start_index <= end_index and loop_break == False:
      mid_index = floor((start_index + end_index) / 2)
      if mass < mass_calc_history[mid_index].mass:
          end_index = mid_index - 1
      elif mass > mass_calc_history[mid_index].mass:
          start_index = mid_index + 1
      else:
          loop_break = True
      end
  end
  if loop_break == False:
      mid_index = start_index
  end

  mass_calc_history.insert(mid_index, struct(mass=mass, cog=cog))
end

thread force_mode_payload_loop():
  textmsg("Starting force mode payload estimation thread")
  mass_calc_history = make_list(0, struct(mass=0.0, cog=0.0), payload_setting_window)
  mass_calc_history.clear()
  local loop_count = 0
  local mass_to_set = 0.0
  local cog_to_set = deafult_payload_cog
  local median_index = 0
  while force_mode_payload_set_active:
    loop_count = loop_count + 1
    ft_raw_wrench = [read_input_float_register(28), read_input_float_register(29), read_input_float_register(30), read_input_float_register(31), read_input_float_register(32), read_input_float_register(33)]
    ft_raw_wrench_offset = [read_input_float_register(34), read_input_float_register(35), read_input_float_register(36), read_input_float_register(37), read_input_float_register(38), read_input_float_register(39)]
    gravity_at_base = p[-1 * read_output_float_register(2), -1 * read_output_float_register(3), -1 * read_output_float_register(4), 0.0, 0.0, 0.0]
    gripper_ft_offset = [read_output_float_register(5), read_output_float_register(6), read_output_float_register(7), read_output_float_register(8), read_output_float_register(9), read_output_float_register(10)]
    
    payload_estim_curr_pos = get_actual_tcp_pose()
    curr_tcp_speed = get_actual_tcp_speed()

    if norm([curr_tcp_speed[0], curr_tcp_speed[1], curr_tcp_speed[2]]) < 0.01:
      payload_estim_speed_check_counter = payload_estim_speed_check_counter + 1.0
    else:
      payload_estim_speed_check_counter = 0.0
    end

    if payload_estim_speed_check_counter > (1.0 / get_steptime()):
      textmsg("The robot is not moving, stopping payload estimation")
      end_force_mode()
      stopj(STOPJ_ACCELERATION)
      socket_send_int(PAYLOAD_SET_EXECUTION_COMPLETE, "script_command_socket")
      payload_estim_result_state_active_count = payload_estim_result_state_active_time / get_steptime()
      payload_estim_result = DP_STATE_TCP_ZERO_VEL
      force_mode_payload_set_active = False
    end


    p_base_wrt_tcp = pose_inv(payload_estim_curr_pos)
    p_gravity_wrt_tcp = pose_trans(p_base_wrt_tcp, gravity_at_base)
    gravity_at_tcp = pose_sub(p_gravity_wrt_tcp, p_base_wrt_tcp)
    curr_gripper_ft = [
      deafult_payload_mass * gravity_at_tcp[0],
      deafult_payload_mass * gravity_at_tcp[1],
      deafult_payload_mass * gravity_at_tcp[2],
      deafult_payload_mass * gravity_at_tcp[0] * deafult_payload_cog[0],
      deafult_payload_mass * gravity_at_tcp[1] * deafult_payload_cog[1],
      deafult_payload_mass * gravity_at_tcp[2] * deafult_payload_cog[2]
    ]

    ft_compensated = ft_raw_wrench - ft_raw_wrench_offset + gripper_ft_offset - curr_gripper_ft

    if force_mode_payload_loop_first_pass == True:
      textmsg("Started payload compensation loop")
      textmsg("Ft raw value: ", ft_raw_wrench)
      textmsg("Ft raw offset value: ", ft_raw_wrench_offset)
      textmsg("Gripper offset value: ", gripper_ft_offset)
      textmsg("Gripper current value: ", curr_gripper_ft)
      force_mode_payload_loop_first_pass = False
    end

    current_raw_force = (ft_compensated[0] * gravity_at_tcp[0] + ft_compensated[1] * gravity_at_tcp[1] + ft_compensated[2] * gravity_at_tcp[2]) / norm([gravity_at_tcp[0], gravity_at_tcp[1], gravity_at_tcp[2]])

    if payload_estim_command_type == DP_FRONT_DRAG or payload_estim_command_type == DP_TOP_LIFT:
      current_raw_force = ft_compensated[2]
    elif payload_estim_command_type == DP_TOP_DRAG:
      current_raw_force = -1.0 * ft_compensated[1]
    elif payload_estim_command_type == DP_FRONT_LIFT:
      current_raw_force = ft_compensated[1]
    end
    
    if current_raw_force < 0.0:
      current_raw_force = 0.0
    end

    current_raw_torque = norm([ft_compensated[3], ft_compensated[4], ft_compensated[5]])

    extra_mass = current_raw_force / 9.81
    if current_raw_force > 0.0:
      calc_cog[2] = (deafult_payload_mass * deafult_payload_cog[2] + extra_mass * (current_raw_torque / current_raw_force)) / (deafult_payload_mass + extra_mass)
      if calc_cog[2] > 0.5:
        calc_cog[2] = 0.5
      end
    end

    if mass_calc_history.length() < 50:
      record_payload_value((deafult_payload_mass + extra_mass), calc_cog[2])
    end

    if loop_count % payload_setting_window != 0:
      sync()
      continue
    end
    loop_count = 0

    eff_pose_diff = pose_trans(payload_estim_start_pos_inv, payload_estim_curr_pos)
    payload_estim_pos_diff = [eff_pose_diff[0], eff_pose_diff[1], eff_pose_diff[2]]
    
    min_estim_distance = min_estim_distance_default
    if payload_estim_command_type == DP_FRONT_LIFT:
      min_estim_distance = min_estim_distance_front_lifting
    end
    
    if norm(payload_estim_pos_diff) > norm([payload_estim_move_distance, payload_estim_secondary_move_distance]):
      textmsg("Stopping payload estimation loop. Gripper moved the payload estimation distance of ", norm(payload_estim_pos_diff))
      end_force_mode()
      stopj(STOPJ_ACCELERATION)
      socket_send_int(PAYLOAD_SET_EXECUTION_COMPLETE, "script_command_socket")
      payload_estim_result_state_active_count = payload_estim_result_state_active_time / get_steptime()
      payload_estim_result = DP_STATE_ESTIMATION_COMPLETE
      force_mode_payload_set_active = False
    else:
      if norm(payload_estim_pos_diff) > min_estim_distance:
        if started_setting_payload == False:
          textmsg("Started setting the payload value, current tcp movement: ", norm(payload_estim_pos_diff))
          started_setting_payload = True
        end
        median_index = floor(mass_calc_history.length() / 2)
        mass_to_set = mass_calc_history[median_index].mass
        cog_to_set[2] = mass_calc_history[median_index].cog
        set_target_payload(mass_to_set, cog_to_set)
        mass_calc_history.clear()
      end
      force_to_apply = (current_raw_force + 300)
      if force_to_apply > force_mode_payload_set_max_force:
        force_to_apply = force_mode_payload_set_max_force
      end
      if payload_estim_command_type == DP_TOP_LIFT:
        
        complaint_axes = [0, 0, 0, 0, 0, 0]
        force_vector = [0.0, 0.0, 0.0, 0.0, 0.0, 0.0]
        force_mode_limits = [0.1, 0.1, 0.1, 0.785, 0.785, 0.785]
        lift_in_progress = False
        if norm(payload_estim_pos_diff[2]) < payload_estim_move_distance:  # if lifting is incomplete
          complaint_axes[2] = 1
          force_vector[2] = -1.0 * force_to_apply
          force_mode_limits[2] = payload_estim_move_speed * (payload_estim_move_distance / norm([payload_estim_move_distance, payload_estim_secondary_move_distance]))  # lift speed
          lift_in_progress = True
        end
        if norm(payload_estim_pos_diff[1]) < payload_estim_secondary_move_distance:  # if pulling is incomplete
          complaint_axes[1] = 1
          force_vector[1] = force_to_apply
          force_mode_limits[1] = payload_estim_move_speed * (payload_estim_secondary_move_distance / norm([payload_estim_move_distance, payload_estim_secondary_move_distance]))  # pull speed
          lift_in_progress = True
        end
        if lift_in_progress == True:
          force_mode(payload_estim_start_pos, complaint_axes, force_vector, 2, force_mode_limits)
        else:
          textmsg("Stopping top lift payload estimation loop. Gripper moved the payload estimation distance of ", norm(payload_estim_pos_diff))
          end_force_mode()
          socket_send_int(PAYLOAD_SET_EXECUTION_COMPLETE, "script_command_socket")
          payload_estim_result_state_active_count = payload_estim_result_state_active_time / get_steptime()
          payload_estim_result = DP_STATE_ESTIMATION_COMPLETE
          force_mode_payload_set_active = False
        end
        
      elif payload_estim_command_type == DP_TOP_DRAG:
        force_mode(payload_estim_start_pos, [0, 1, 0, 0, 0, 0], [0, force_to_apply, 0, 0, 0, 0], 2, [0.1, payload_estim_move_speed, 0.1, 0.785, 0.785, 0.785])
      elif payload_estim_command_type == DP_FRONT_LIFT:
        
        complaint_axes = [0, 0, 0, 0, 0, 0]
        force_vector = [0.0, 0.0, 0.0, 0.0, 0.0, 0.0]
        force_mode_limits = [0.1, 0.1, 0.1, 0.785, 0.785, 0.785]
        lift_in_progress = False
        if norm(payload_estim_pos_diff[1]) < payload_estim_move_distance:  # if lifting is incomplete
          complaint_axes[1] = 1
          force_vector[1] = -1.0 * force_to_apply
          force_mode_limits[1] = payload_estim_move_speed * (payload_estim_move_distance / norm([payload_estim_move_distance, payload_estim_secondary_move_distance]))  # lift speed
          lift_in_progress = True
        end
        if norm(payload_estim_pos_diff[2]) < payload_estim_secondary_move_distance:  # if pulling is incomplete
          complaint_axes[2] = 1
          force_vector[2] = -1.0 * force_to_apply
          force_mode_limits[2] = payload_estim_move_speed * (payload_estim_secondary_move_distance / norm([payload_estim_move_distance, payload_estim_secondary_move_distance]))  # pull speed
          lift_in_progress = True
        end
        if lift_in_progress == True:
          force_mode(payload_estim_start_pos, complaint_axes, force_vector, 2, force_mode_limits)
        else:
          textmsg("Stopping top lift payload estimation loop. Gripper moved the payload estimation distance of ", norm(payload_estim_pos_diff))
          end_force_mode()
          socket_send_int(PAYLOAD_SET_EXECUTION_COMPLETE, "script_command_socket")
          payload_estim_result_state_active_count = payload_estim_result_state_active_time / get_steptime()
          payload_estim_result = DP_STATE_ESTIMATION_COMPLETE
          force_mode_payload_set_active = False
        end

      elif payload_estim_command_type == DP_FRONT_DRAG:
        force_mode(payload_estim_start_pos, [0, 0, 1, 0, 0, 0], [0, 0, (-1.0 * force_to_apply), 0, 0, 0], 2, [0.1, 0.1, payload_estim_move_speed, 0.785, 0.785, 0.785])
      end
    end
    sync()
  end
  textmsg("Exiting payload estimation thread")
end

thread services_execution_thread():
  while True:

    # Tool contact is running, but hasn't been detected
    if tool_contact_running == True and control_mode != MODE_TOOL_IN_CONTACT:
      tool_contact_detection()
    end

    if detect_box_slip == True:
      box_slip_detection()
    end

    if force_mode_payload_set_active == True:
      write_output_integer_register(0, DP_STATE_ESTIMATING)
    else:
      if payload_estim_result_state_active_count > 0:
        write_output_integer_register(0, payload_estim_result)
        payload_estim_result_state_active_count = payload_estim_result_state_active_count - 1
      else:
        write_output_integer_register(0, DP_STATE_INACTIVE)
      end
    end
    
    register_payload_mass = read_input_float_register(24)
    
    if consider_register_payload_values == False:
      if is_initial_script == True:
        if default_payload_set == False:
          default_payload_set = True
          textmsg("Setting the default payload value: ", deafult_payload_mass)
          # set_target_payload(deafult_payload_mass, deafult_payload_cog)
        end
        if norm(register_payload_mass - deafult_payload_mass) < 0.01:
          consider_register_payload_values = True
          textmsg("Detected default payload value. Switching to register payload values.")
        end
      else:
        consider_register_payload_values = True
        textmsg("Not in initial script. Switching to register payload values.")
      end
    end
    
    # if consider_register_payload_values == True:
    #   if norm(register_payload_mass - get_target_payload()) > 0.01 and run_set_payload_loop == False:
    #     textmsg("Detected new payload value. Setting payload to new value: ", register_payload_mass)
    #     register_payload_cog[0] = read_input_float_register(25)
    #     register_payload_cog[1] = read_input_float_register(26)
    #     register_payload_cog[2] = read_input_float_register(27)
    #     target_payload_mass = register_payload_mass
    #     target_payload_cog = register_payload_cog
    #     payload_loop_first_pass = True
    #     run_set_payload_loop = True
    #   end
    # end
    
    if run_set_payload_loop == True:
      set_payload_loop()
    end
    sync()
  end
end

def box_slip_detection():
  joints_position_deviation = get_target_joint_positions() - get_actual_joint_positions()
  
  max_position_deviation = 0.0
  idx = 0
  while idx < 6:
    if norm(joints_position_deviation[idx]) > max_position_deviation:
      max_position_deviation = norm(joints_position_deviation[idx])
    end
    idx = idx + 1
  end

  if max_position_deviation > trigger_position_deviation:
    textmsg("Box slip detected. Max deviation: ", max_position_deviation)
    textmsg("Commanding LOW signal to tool digital IO")
    set_tool_digital_out(0, False)
    set_tool_digital_out(1, False)
    target_payload_mass = deafult_payload_mass
    target_payload_cog = deafult_payload_cog
    payload_loop_first_pass = True
    run_set_payload_loop = True
    detect_box_slip = False
    textmsg("Stopping box slip detection.")
  end
end

# Thread to receive one shot script commands, the commands shouldn't be blocking
thread script_commands():
  while control_mode > MODE_STOPPED:
    raw_command = socket_read_binary_integer(SCRIPT_COMMAND_DATA_DIMENSION, "script_command_socket", 0)
    if raw_command[0] > 0:
      command = raw_command[1]
      if command == ZERO_FTSENSOR:
        p_base_wrt_tcp = pose_inv(get_actual_tcp_pose())
        p_gravity_wrt_tcp = pose_trans(p_base_wrt_tcp, gravity_at_base)
        gravity_at_tcp = pose_sub(p_gravity_wrt_tcp, p_base_wrt_tcp)
        curr_gripper_ft = [
          deafult_payload_mass * gravity_at_tcp[0],
          deafult_payload_mass * gravity_at_tcp[1],
          deafult_payload_mass * gravity_at_tcp[2],
          deafult_payload_mass * gravity_at_tcp[0] * deafult_payload_cog[0],
          deafult_payload_mass * gravity_at_tcp[1] * deafult_payload_cog[1],
          deafult_payload_mass * gravity_at_tcp[2] * deafult_payload_cog[2]
        ]
        textmsg("Gravity at base: ", gravity_at_base)
        textmsg("pose base wrt tcp: ", p_base_wrt_tcp)
        textmsg("pose gravity wrt tcp: ", p_gravity_wrt_tcp)
        textmsg("Gravity at tcp: ", gravity_at_tcp)
        textmsg("Current gripper ft: ", curr_gripper_ft)
        write_output_float_register(5, curr_gripper_ft[0])
        write_output_float_register(6, curr_gripper_ft[1])
        write_output_float_register(7, curr_gripper_ft[2])
        write_output_float_register(8, curr_gripper_ft[3])
        write_output_float_register(9, curr_gripper_ft[4])
        write_output_float_register(10, curr_gripper_ft[5])
        zero_ftsensor()
        textmsg("Zeroed ft sensor.")
      elif command == SET_PAYLOAD:
        target_payload_mass = raw_command[2] / MULT_jointstate
        target_payload_cog = [raw_command[3] / MULT_jointstate, raw_command[4] / MULT_jointstate, raw_command[5] / MULT_jointstate]
        payload_loop_first_pass = True
        run_set_payload_loop = True
        # set_payload(target_payload_mass, target_payload_cog)
        # textmsg("Payload set successfully.")
      elif command == SET_TOOL_VOLTAGE:
        tool_voltage = raw_command[2] / MULT_jointstate
        set_tool_voltage(tool_voltage)
      elif command == START_FORCE_MODE:
        task_frame = p[raw_command[2] / MULT_jointstate, raw_command[3] / MULT_jointstate, raw_command[4] / MULT_jointstate, raw_command[5] / MULT_jointstate, raw_command[6] / MULT_jointstate, raw_command[7] / MULT_jointstate]
        selection_vector = [raw_command[8] / MULT_jointstate, raw_command[9] / MULT_jointstate, raw_command[10] / MULT_jointstate, raw_command[11] / MULT_jointstate, raw_command[12] / MULT_jointstate, raw_command[13] / MULT_jointstate]
        wrench = [raw_command[14] / MULT_jointstate, raw_command[15] / MULT_jointstate, raw_command[16] / MULT_jointstate, raw_command[17] / MULT_jointstate, raw_command[18] / MULT_jointstate, raw_command[19] / MULT_jointstate]
        force_type = raw_command[20] / MULT_jointstate
        force_limits = [raw_command[21] / MULT_jointstate, raw_command[22] / MULT_jointstate, raw_command[23] / MULT_jointstate, raw_command[24] / MULT_jointstate, raw_command[25] / MULT_jointstate, raw_command[26] / MULT_jointstate]
        force_mode(task_frame, selection_vector, wrench, force_type, force_limits)
      elif command == END_FORCE_MODE:
        end_force_mode()
      elif command == START_TOOL_CONTACT:
        tool_contact_first_pass = True
        tool_contact_running = True
        textmsg("Starting tool contact")
      elif command == END_TOOL_CONTACT:
        if control_mode != MODE_TOOL_IN_CONTACT:
          # If tool contact hasn't been detected send canceled result
          socket_send_int(UNTIL_TOOL_CONTACT_RESULT_CANCELED, "script_command_socket")
        else:
          end_force_mode()
        end
        tool_contact_running = False
      elif command == SET_GRAVITY:
        gravity = [raw_command[2] / MULT_jointstate, raw_command[3] / MULT_jointstate, raw_command[4] / MULT_jointstate]
        write_output_float_register(2, gravity[0])
        write_output_float_register(3, gravity[1])
        write_output_float_register(4, gravity[2])
        set_gravity(gravity)
        textmsg("ExternalControl: Setting gravity: ", gravity)
      elif command == SET_DYNAMIC_PAYLOAD:
        control_mode = PAYLOAD_ESTIMATION
        payload_estim_command_type = raw_command[2]
        payload_estim_move_distance = raw_command[3] / MULT_jointstate
        payload_estim_secondary_move_distance = raw_command[4] / MULT_jointstate
        payload_estim_move_speed = raw_command[5] / MULT_jointstate
        payload_estim_start_pos = get_actual_tcp_pose()
        payload_estim_start_pos_inv = pose_inv(payload_estim_start_pos)
        textmsg("Received dynamic payload estimation command with command type: ", payload_estim_command_type)
        textmsg("Received dynamic payload estimation command with move distance: ", payload_estim_move_distance)
        textmsg("Received dynamic payload estimation command with secondary move distance: ", payload_estim_secondary_move_distance)
        textmsg("Received dynamic payload estimation command with move speed: ", payload_estim_move_speed)
        textmsg("Move speed: ", payload_estim_move_speed * (payload_estim_move_distance / norm([payload_estim_move_distance, payload_estim_secondary_move_distance])))
        textmsg("Secondary move speed: ", payload_estim_move_speed * (payload_estim_secondary_move_distance / norm([payload_estim_move_distance, payload_estim_secondary_move_distance])))
        started_setting_payload = False
        payload_estim_speed_check_counter = 0.0
        force_mode_payload_loop_first_pass = True
        force_mode_payload_set_active = True
      elif command == SET_BOX_SLIP_DETECTION:
        textmsg("Setting box slip detection")
        if raw_command[2] == DETECT_BOX_SLIP_ACTIVATE:
          textmsg("Activated box slip detection")
          detect_box_slip = True
        elif raw_command[2] == DETECT_BOX_SLIP_DEACTIVATE:
          textmsg("Deactivating box slip detection")
          detect_box_slip = False
        else:
          textmsg("Unknown box slip detection command: ", raw_command[2])
        end
      end
    end
  end
end

# HEADER_END

# NODE_CONTROL_LOOP_BEGINS
socket_open("{{SERVER_IP_REPLACE}}", {{SERVER_PORT_REPLACE}}, "reverse_socket")
socket_open("{{SERVER_IP_REPLACE}}", {{TRAJECTORY_SERVER_PORT_REPLACE}}, "trajectory_socket")
socket_open("{{SERVER_IP_REPLACE}}", {{SCRIPT_COMMAND_SERVER_PORT_REPLACE}}, "script_command_socket")

force_mode_set_damping({{FORCE_MODE_SET_DAMPING_REPLACE}})
force_mode_set_gain_scaling({{FORCE_MODE_SET_GAIN_SCALING_REPLACE}})

control_mode = MODE_UNINITIALIZED
thread_move = 0
thread_trajectory = 0
trajectory_points_left = 0
thread_payload_estimation = 0
textmsg("ExternalControl: External control active...")
if is_initial_script == True:
  textmsg("ExternalControl: Running initial script")
end
write_output_float_register(2, 0.0)
write_output_float_register(3, 0.0)
write_output_float_register(4, 9.81)
global read_timeout = 0.0 # First read is blocking
thread_script_commands = run script_commands()
thread_services_execution = run services_execution_thread()
while control_mode > MODE_STOPPED:
  enter_critical
  params_mult = socket_read_binary_integer(REVERSE_INTERFACE_DATA_DIMENSION, "reverse_socket", read_timeout)
  if params_mult[0] > 0:
    # Convert to read timeout from milliseconds to seconds
    read_timeout = params_mult[1] / 1000.0 
    if control_mode != params_mult[REVERSE_INTERFACE_DATA_DIMENSION]:
      # Clear remaining trajectory points
      if control_mode == MODE_FORWARD:
        kill thread_trajectory
        clear_remaining_trajectory_points()
        stopj(STOPJ_ACCELERATION)
        socket_send_int(TRAJECTORY_RESULT_CANCELED, "trajectory_socket")
      # Stop freedrive
      elif control_mode == MODE_FREEDRIVE:
        textmsg("Leaving freedrive mode")
        end_freedrive_mode()
      end

      # If tool is in contact, tool contact should be ended before switching control mode
      if control_mode == MODE_TOOL_IN_CONTACT:
        if tool_contact_running == False:
          control_mode = params_mult[REVERSE_INTERFACE_DATA_DIMENSION]
        end
      elif control_mode == PAYLOAD_ESTIMATION:
        if force_mode_payload_set_active == True:
          if payload_estimation_thread_started == False:
            join thread_move
            thread_payload_estimation = run force_mode_payload_loop()
            payload_estimation_thread_started = True
          end
        else:
          kill thread_payload_estimation
          join thread_payload_estimation
          payload_estimation_thread_started = False
          control_mode = params_mult[REVERSE_INTERFACE_DATA_DIMENSION]
          join thread_move
        end
      else:
        control_mode = params_mult[REVERSE_INTERFACE_DATA_DIMENSION]
        join thread_move
      end
      if control_mode == MODE_SERVOJ:
        thread_move = run servoThread()
      elif control_mode == MODE_SPEEDJ:
        thread_move = run speedThread()
      elif control_mode == MODE_FORWARD:
        kill thread_move
        stopj(STOPJ_ACCELERATION)
      elif control_mode == MODE_SPEEDL:
        thread_move = run speedlThread()
      elif control_mode == MODE_POSE:
        thread_move = run servoThreadP()
      end
    end

    # Update the motion commands with new parameters
    if control_mode == MODE_SERVOJ:
      q = [params_mult[2]/ MULT_jointstate, params_mult[3]/ MULT_jointstate, params_mult[4]/ MULT_jointstate, params_mult[5]/ MULT_jointstate, params_mult[6]/ MULT_jointstate, params_mult[7]/ MULT_jointstate]
      set_servo_setpoint(q)
    elif control_mode == MODE_SPEEDJ:
      qd = [params_mult[2]/ MULT_jointstate, params_mult[3]/ MULT_jointstate, params_mult[4]/ MULT_jointstate, params_mult[5]/ MULT_jointstate, params_mult[6]/ MULT_jointstate, params_mult[7]/ MULT_jointstate]
      set_speed(qd)
    elif control_mode == MODE_FORWARD:
      if params_mult[2] == TRAJECTORY_MODE_RECEIVE:
        kill thread_trajectory
        clear_remaining_trajectory_points()
        trajectory_points_left = params_mult[3]
        thread_trajectory = run trajectoryThread()
      elif params_mult[2] == TRAJECTORY_MODE_CANCEL:
        textmsg("cancel received")
        kill thread_trajectory
        clear_remaining_trajectory_points()
        stopj(STOPJ_ACCELERATION)
        socket_send_int(TRAJECTORY_RESULT_CANCELED, "trajectory_socket")
      end
    elif control_mode == MODE_SPEEDL:
      twist = [params_mult[2] / MULT_jointstate, params_mult[3] / MULT_jointstate, params_mult[4] / MULT_jointstate, params_mult[5] / MULT_jointstate, params_mult[6] / MULT_jointstate, params_mult[7] / MULT_jointstate]
      set_speedl(twist)
    elif control_mode == MODE_POSE:
      pose = p[params_mult[2] / MULT_jointstate, params_mult[3] / MULT_jointstate, params_mult[4] / MULT_jointstate, params_mult[5] / MULT_jointstate, params_mult[6] / MULT_jointstate, params_mult[7] / MULT_jointstate]
      set_servo_pose(pose)
    elif control_mode == MODE_FREEDRIVE:
      if params_mult[2] == FREEDRIVE_MODE_START:
        textmsg("Entering freedrive mode")
        freedrive_mode()
      elif params_mult[2] == FREEDRIVE_MODE_STOP:
        textmsg("Leaving freedrive mode")
        end_freedrive_mode()
      end
    end
  else:
    textmsg("Socket timed out waiting for command on reverse_socket. The script will exit now.")
    control_mode = MODE_STOPPED
  end
  exit_critical
end

textmsg("ExternalControl: Stopping communication and control")
kill thread_move
kill thread_trajectory
kill thread_script_commands
kill thread_services_execution
stopj(STOPJ_ACCELERATION)
textmsg("ExternalControl: All threads ended")
socket_close("reverse_socket")
socket_close("trajectory_socket")
socket_close("script_command_socket")

# NODE_CONTROL_LOOP_ENDS
